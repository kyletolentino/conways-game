2/8/2020
- need to figure out:
    - best architecture for NN
        - RNN/LSTM? dealing with sequential data
        - CNN? usually with images, but since there are two matrices, just stack em?
    - creating a virtualenv on EWS (can't use anaconda on these machines)
        - pandas
        - keras
        - TF 2.1
        - python 3.5.2 (only available python module on EWS that supports Keras and TF2.0-1)
        - seaborn
        - scikit-learn
    - how to create data
        - IDEA: create two/three functions that returns a tuple of matrices (start, done)
        - function1 will create correct matrices, function2/3 will create incorrect matrices
            - for incorrect, may do random and/or variation of function1, where I change few values
            - right now, will only create 1 real and 1 fake function
        - NOTE: I will assume a 3x3 grid size for keras challenge
        - aiming for even distribution of fake and real

    

2/7/2020
- Setup git on Engineering Workstation (EWS)
- np.random.randit to generate 0s and 1s randomly
- need to figure out way to store previous state while iterating

- three cases: (1)Corners, (2)Sides/Edges, (3)Everything else
- Corners have 3 neighbors
- Sides/Edges have 5 neighbors
- Everything else has 8 neighbors (holds true for even x even matrices, par 2x2)

- 0x0, 1x1, 2x2 special cases (DONT FORGET)
- goal: move contents from game.py into another function (so I can call for x generations)
- need-to-do: figure out how to account for edges lol

- updated else check because I counted the 1 for the position we were looking at
- might need to just combine all functions into 1
    - provided that I put in conditions that prevent out of bounds (corner and edge)
    - might try continue if x,y go out of bounds (especially with -1,-1)
- got it to work!! (for most part)
    - (2,1) is 1 but should be 0
    - running func((2,1), state) returns a 0 but not on the board

- EUREEEKA!
    - I think it was the way I assigned ex[x,y] in game.py
    - Should have created copy first (with dim of first state)
    - then copy within for loops

- Now I need to:
    - test this for different dimensions
        - consider 0x0, 1x1, 2x2 cases
    - Create function to run this for x generations
        - pretty sure I have to use recursion
        - yea I have to lol (it works tho!)
    - Improve UI and arguments (argparse)

- [starting] Part 2 !! (in a bit b/c of argparse)


2/6/2020
- Initialized git for source control
- doing 2 for loops (x,y), might consider np.ndenumerate (read something about large dimensions)